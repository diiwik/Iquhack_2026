import math
import cudaq

@cudaq.kernel
def rzz(q0: cudaq.qubit, q1: cudaq.qubit, theta: float):
    cx(q0, q1)
    rz(2 * theta, q1)
    cx(q0, q1)

@cudaq.kernel
def two_qubit_block(q0: cudaq.qubit, q1: cudaq.qubit, theta: float):
    rx(math.pi / 2, q1)
    rzz(q0, q1, theta)
    rx(-math.pi / 2, q1)

    rx(math.pi / 2, q0)
    rzz(q0, q1, theta)
    rx(-math.pi / 2, q0)

@cudaq.kernel
def four_qubit_block(
    q0: cudaq.qubit,
    q1: cudaq.qubit,
    q2: cudaq.qubit,
    q3: cudaq.qubit,
    theta: float
):
    rx(-math.pi/2, q0)
    ry(math.pi/2, q1)
    ry(-math.pi/2, q2)
    rzz(q0, q1, -theta)
    rzz(q2, q3, -theta)
    rx(math.pi/2, q0)
    ry(-math.pi/2, q1)
    rx(-math.pi/2, q1)
    ry(math.pi/2, q2)
    rx(-math.pi/2, q2)
    rx(-math.pi/2, q3)
    rzz(q1, q2, theta)

    rx(math.pi/2, q1)
    rx(math.pi, q2)
    ry(-math.pi/2, q1)
    rzz(q0, q1, theta)
    rx(math.pi/2, q0)
    ry(-math.pi/2, q1)
    rzz(q1, q2, -theta)
    rx(math.pi/2, q1)
    rx(-math.pi, q2)
    rzz(q1, q2, -theta)

    rx(-math.pi, q1)
    ry(math.pi/2, q1)
    rzz(q2, q3, -theta)
    ry(-math.pi/2, q2)
    rx(-math.pi/2, q3)
    rx(-math.pi/2, q2)

    rzz(q1, q2, theta)
    rx(math.pi/2, q1)
    rx(math.pi/2, q2)
    ry(-math.pi/2, q1)
    ry(math.pi/2, q2)
    rzz(q0, q1, theta)
    rzz(q2, q3, theta)
    ry(math.pi/2, q1)
    ry(-math.pi/2, q2)
    rx(math.pi/2, q3)

def get_interactions(N: int):
    G2 = []
    G4 = []

    # Two-body terms
    for i in range(N - 2):
        max_k = (N - i) // 2
        for k in range(1, max_k + 1):
            G2.append([i, i + k])

    # Four-body terms
    for i in range(N - 3):
        max_t = (N - i - 1) // 2
        for t in range(1, max_t + 1):
            for k in range(t + 1, N - i - t):
                G4.append([i, i + t, i + k, i + k + t])

    return G2, G4

@cudaq.kernel
def trotterized_circuit(
    N: int,
    G2: list[list[int]],
    G4: list[list[int]],
    steps: int,
    dt: float,
    thetas: list[float]
):
    reg = cudaq.qvector(N)

    # Initial |+>^N state
    for q in reg:
        h(q)

    # Trotter steps
    for step in range(steps):
        theta = thetas[step]

        # 2-body terms
        for term in G2:
            i, j = term
            two_qubit_block(reg[i], reg[j], dt * theta)

        # 4-body terms
        for term in G4:
            i, j, k, l = term
            four_qubit_block(
                reg[i],
                reg[j],
                reg[k],
                reg[l],
                dt * theta
            )
# Parameters
T = 1.0
n_steps = 1
dt = T / n_steps
N = 20

# Interactions
G2, G4 = get_interactions(N)

# Example theta schedule (placeholder â€“ replace with CD formula if needed)
thetas = [1.0 for _ in range(n_steps)]

# Sample
result = cudaq.sample(
    trotterized_circuit,
    N,
    G2,
    G4,
    n_steps,
    dt,
    thetas,
    shots_count=100
)

print(result)