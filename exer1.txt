#TODO - Write code to perform MTS

import numpy as np
def random_seq(N):
    return np.random.choice([-1, 1], size=N).astype(np.int8)
def labs_energy(s):
    N = len(s)
    E = 0
    for k in range(1, N):
        Ck = np.sum(s[:-k] * s[k:])
        E += Ck * Ck
    return E
def tabu_search(start, iters=200, tenure=7):
    N = len(start)
    cur = start.copy()
    curE = labs_energy(cur)
    best = cur.copy()
    bestE = curE

    tabu_until = np.zeros(N, dtype=int)  # when each index stops being tabu

    for t in range(1, iters + 1):
        best_move = None
        best_move_E = None

        for i in range(N):
            # aspiration: allow tabu move if it improves global best
            is_tabu = tabu_until[i] > t
            cur[i] *= -1
            E = labs_energy(cur)
            if (not is_tabu) or (E < bestE):
                if (best_move is None) or (E < best_move_E):
                    best_move = i
                    best_move_E = E
            cur[i] *= -1

        if best_move is None:
            break

        # apply move
        i = best_move
        cur[i] *= -1
        curE = best_move_E
        tabu_until[i] = t + tenure

        if curE < bestE:
            bestE = curE
            best = cur.copy()

    return best, bestE
def crossover(parent1, parent2):
    N = len(parent1)
    point = np.random.randint(1, N)
    child = np.empty_like(parent1)
    child[:point] = parent1[:point]
    child[point:] = parent2[point:]
    return child
def mutate(s, p_mut):
    flip_mask = np.random.rand(len(s)) < p_mut
    s2 = s.copy()
    s2[flip_mask] *= -1
    return s2
def memetic_tabu_search(N, K=100, p_comb=0.9, p_mut=None, max_evals=10_000, ts_iters=200, tenure=7,):
    if p_mut is None:
        p_mut = 1.0 / N

    # 1) random initial population
    pop = [random_seq(N) for _ in range(K)]
    energies = [labs_energy(s) for s in pop]
    evals = K

    best_idx = int(np.argmin(energies))
    best = pop[best_idx].copy()
    bestE = energies[best_idx]

    while evals < max_evals:
        # 2) pick parents / single parent
        if np.random.rand() < p_comb:
            i, j = np.random.choice(K, size=2, replace=False)
            child = crossover(pop[i], pop[j])
        else:
            i = np.random.randint(K)
            child = pop[i].copy()

        # 3) mutation
        child = mutate(child, p_mut)

        # 4) local improvement by tabu search
        improved, E_improved = tabu_search(child, iters=ts_iters, tenure=tenure)
        evals += ts_iters  # crude count; you can count exact evaluations if you log them

        # 5) population update
        if E_improved < bestE:
            bestE = E_improved
            best = improved.copy()

        # replace random individual if child is better
        worst_idx = np.argmax(energies)
        if E_improved < energies[worst_idx]:
            replace_idx = np.random.randint(K)
            pop[replace_idx] = improved
            energies[replace_idx] = E_improved

    return best, bestE

best, bestE = memetic_tabu_search(N=27)
print(bestE)
print(best)
